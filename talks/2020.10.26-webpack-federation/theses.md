- Проблемы большого фронтенда:
  - фронтенд большой, и несколько команд его пилят
  - разделение ответственности (кто за что отвечает)
  - долгие часы CI/CD и интеграционных тестов, чтоб собрать монолитный фронтенд
  - А как было здорово лет 5 тому назад:
    - никаких билдов, влепил jquery плагин на страницу и поехали
    - сейчас с билдами боишься лишний скрипт подключить. Такое ощущение, что атрофировалось способность что-то подключать руками.
  - Принцип: Разделяй и властвую
- Что такое микрофронтенды?
  - Сперва взглянем на бекендерский аналог – microservices
  - Микросервисы это широко распространенный архитектурный паттерн для разработки бэкендов. Микросервисные системы объединяют небольшие независимо разворачиваемые сервисы, которые запускаются в разных процессах (машинах) и комуницируют по сети.
  - Микросервисы преследуют низкую связность компонентов системы между собой, что дает высокую автономность командам:
    - разделенные кодовой базы и ответственности
    - независимое развертывание
    - лучшая ориентация на клиента
  - Microfrontends – аналогичный архитектурный паттерн для фронтенда
    - Как и микросервисы, они нацелены на обеспечение высокой автономии команд
    - Но зрелость методов и технологий гораздо ниже, чем у микросервисов.
  - Микрофронтенды – это архитектурный стиль, в котором независимо доставляемые клиентские компоненты в браузер объединяются в единое целое.
  - A micro-frontend represents a business domain that is autonomous, is independently deliverable, and is owned by a team.
  - Microfrontends are modelled to match organization structure.
- Что дают микрофронтенды?
  - Упрощение координации задач - команды более сфокусированы на своих предметных областях, четкая зона ответственности.
  - Возможность независимого развертывания - позволяет командам быть более автономными
  - Сокращение цикла поставки - более быстрая сборка и тесты. Как нового функционала, так и исправления ошибок.
  - Снижение сложности - отдельные части меньше и легче для понимания, чем большой сложный монолит.
  - Изоляция ошибок - может быть проще изолировать сбои в отдельных частях приложения, пока остальная часть приложения работает.
  - Фокус на предметной области и эффективность
- Технические требования к микрофронтендам
  - автономность команд и независимый деплой микрофронтендов (наиболее важный аспект)
    - Проблемы, которые решают микрофронтенды, в основном являются организационными, а не техническими. Такая проблема - это способность разных частей организации действовать независимо. Иметь возможность выпускать свой код в продакшен без одобрения остальных.
  - сокращение времени сборки
    - На сборку и автотесты больших интерфейсных приложений могут уходить часы, что значительно удлиняет цикл обратной связи с разработчиками. Разделив приложение на более мелкие части, мы можем радикально ускорить сборку и тесты.
  - переиспользование общего кода
    - для фронтенда важным ограничением является объем данных загруженных по сети, и чем он меньше тем лучше. Частая болячка микрофронтендов дублирование библиотек и кода фреймворков в их бандлах. В связи с этим мы максимально должны стараться переиспользовать общие модули и компоненты. Крайне важно придерживаться semantic versioning – BREAKING.FEATURE.FIX. И иметь механизм в микрофронтендах для анонсирования необходимых версий модулей и их загрузку в рантайме.
    - Болячки микрофронтендов
  - безопасное выполнение микрофронтендов
    - Микрофронтендов выполняются в браузере и работают в одном потоке. Модель DOM, которую можно рассматривать как замену хранилища данных, является общей, что означает, что они обращаются к одному и тому же хранилищу данных и изменяют его. И ошибка в одном микрофронтенде, может положить все клиентское приложение.
  - SSR – возможность генерации HTML-код страницы для поисковиков
  - Возможность управлять одним микрофронтендом из другого – к примеру, в sidebar'e показывать пункты меню, которые задаются в другом микросервисе
- Существующие решения
  - свой велосипед
    - обычно дорого – R&D, тесты, документация, bus factor
  - Server-Side Fragment Composition
    - Также известно под словами transclusion, Server Side Includes. Применяется на бэкенде. Когда веб-сервер собирает html-страницу из разных кусков (сервисов) в единую html страницу. Очень древняя технология.
    - Nginx SSI
    - Zalando Tailor – is a layout service that uses streams to compose a web page from fragment services.
    - слабо-применима к современным SPA-приложениям
  - Iframes
    - transclusion который работает на клиенте. Который позволяет собирать html страницу из других html страниц. Появился как стандарт в HTML 4.01 (1998 год).
    - zoid (ифреймы могут общаться через postMessage)
    - боль с модальными окнами, и управлением лейаута
    - проблема с SEO для поисковиков
    - проблема с перформансом (одни и те же библиотеки загружаются несколько раз)
  - Web Components
    - Гораздо более новым веб-стандартом являются веб-компоненты. Они позволяют определять и регистрировать динамические настраиваемые элементы в инкапсулированной области.
    - Самая большая проблема с SSR, т.к web components сильно завязаны на DOM API
    - Поможет инкапсулировать компонент, но не поможет сделать большое SPA приложение
    - По мне чутка поумневший iframe не более того.
  - Linked Pages and SPAs
    - Microfrontends can be integrated on the server, on the client, or a combination of both [36]. The simplest server side integration is to serve different web pages on different endpoints [36]. All traditional tools and processes can be used to develop the separate pages, and the different microfrontends can be SPAs. This can be achieved with a web proxy to serve the different pages on a single domain address, which is visualized in Figure 3.4.1. Geers calls this technique Linked Pages if every page is a separate application, and Linked SPAs if some pages are grouped into one SPA [27]. When using Linked SPAs page navigation is hard when navigating between SPAs and soft when navigating internally in an SPA.
    - next.js Multi Zones
  - single-spa
    - Один из самых популярных фреймворков на данный момент для SPA. Это приложение-оболочка, которое включает приложения, разработанные с использованием других фреймворков. Он ведет себя как тонкий слой оркестровки, который согласно URL запускает тот или иной микрофронтенд, "выключая" предыдущий.
    - погружаемся в systemjs и мапперы, что-то костылим с подгрузкой ассетов css, fonts, images
    - проблема с переиспользованием кода, хотя lazy loading по роуту страницы позволяет сократить первоначальную загрузку
  - Module Federation
    - Module Federation is an addition to the web bundler Webpack that allows an application to consist of more than one deployment unit [37, 67]. The extension allows encapsulated compiled deployment units to expose functionality and consume functionality from other deployment units [37, 67]. This way separate deployment units can share dependencies and depend on each other. The composition is done at run-time, which facilitates independent deployments.
    - Federated modules could have a large impact on microfrontends, as it allows developers to write applications as if they are monolithic, when they in practice are distributed over multiple projects. There is a potential for frameworks to emerge that are built on top of the functionality of module federation.
    - Module federation aims to enable microfrontends to share common code in an easy manner. In projects where module federation is used, there should be a very small impact to bundle sizes, as code duplication is avoided by enabling easy sharing.
    - module federation в webpack 5 (вот она рыба моей мечты. зарелизели в октябре 2020)
    - не все паттерны и стратегии еще выработаны. Нам дали мяч, а вот с правилами игры пока не все ясно.
- История Module Federation
  - Zackary Jackson author of flagship feature for Webpack 5, module federation
- Стратегии использования Module Federation
  - Zackary suggests that anything that is shared across many microfrontends could be placed in the integration layer. Examples are user authentication and user data. Zackary usually places the website footer and navigation bar in the integration layer, as it is shared across the application.
  - State management. Michael, Joel, and Zackary all mentioned that it is important to consider what application state is shared between microfrontends and how it is shared. Global application state stores should be avoided, as it adds tight coupling between microfrontends. If two microfrontends share a lot of state, they should in many cases be merged into one microfrontend.
- Стратегии реализации микрофронтендов
  - тонкий шелл
  - толстый шелл
  - и еще 100500 других
- Демо
  - как работает (неглубоко без кишков)
  - кто реализует и можно ли доверять
  - где посмотреть больше демок
  - будут ли проблемы со сборкой, хэшами, ошибки в рантайме
- Что дальше:
  - Microfrontends is still a new technology. All interviewees mentioned expectations for the technology to mature and grow in popularity. They also expect new patterns and best practices to emerge.
  - Zackary expects tools to emerge from module federation. Module federation is a low level construct, and will become more powerful when it is used to create tools built using it. Zackary expects frontend frameworks to use it to compose shared assets.
  - Ждем Next.js 10, но уже сейчас можно клеить микрофронтенды.
  - Выход с докладом на весну 2021: apollo federation, webpack module federation, russian federation – как сделать так, чтобы все федерации работали как часы?!
