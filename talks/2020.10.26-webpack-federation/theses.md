- Сперва короткое Демо, чтоб заинтриговать темой
  - A short and sweet guide to using Module Federation on two independently deployed web apps, so that they can work like a monolith.
- Про module federation буду рассказывать минут через 20 ищите слайд X.Y. А пока немного теории, предыстории для общего понимания.
- Проблемы большого фронтенда:
  - фронтенд большой, и несколько команд его пилят
  - разделение ответственности (кто за что отвечает)
  - долгие часы CI/CD и интеграционных тестов, чтоб собрать монолитный фронтенд
  - А как было здорово лет 5 тому назад:
    - никаких билдов, влепил jquery плагин на страницу и поехали
    - сейчас с билдами боишься лишний скрипт подключить. Такое ощущение, что атрофировалось способность что-то подключать руками.
  - Принцип: Разделяй и властвую
- Что такое микрофронтенды?
  - Сперва взглянем на бекендерский аналог – microservices
  - Микросервисы это широко распространенный архитектурный паттерн для разработки бэкендов. Микросервисные системы объединяют небольшие независимо разворачиваемые сервисы, которые запускаются в разных процессах (машинах) и комуницируют по сети.
  - Микросервисы преследуют низкую связность компонентов системы между собой, что дает высокую автономность командам:
    - разделенные кодовой базы и ответственности
    - независимое развертывание
    - лучшая ориентация на клиента
  - Microfrontends – аналогичный архитектурный паттерн для фронтенда
    - Как и микросервисы, они нацелены на обеспечение высокой автономии команд
    - Но зрелость методов и технологий гораздо ниже, чем у микросервисов.
  - Микрофронтенды – это архитектурный стиль, в котором независимо доставляемые клиентские компоненты в браузер объединяются в единое целое.
  - A micro-frontend represents a business domain that is autonomous, is independently deliverable, and is owned by a team.
  - Microfrontends are modelled to match organization structure.
- Что дают микрофронтенды?
  - Упрощение координации задач - команды более сфокусированы на своих предметных областях, четкая зона ответственности.
  - Возможность независимого развертывания - позволяет командам быть более автономными
  - Сокращение цикла поставки - более быстрая сборка и тесты. Как нового функционала, так и исправления ошибок.
  - Снижение сложности - отдельные части меньше и легче для понимания, чем большой сложный монолит.
  - Изоляция ошибок - может быть проще изолировать сбои в отдельных частях приложения, пока остальная часть приложения работает.
  - Фокус на предметной области и эффективность
- Технические требования к микрофронтендам
  - автономность команд и независимый деплой микрофронтендов (наиболее важный аспект)
    - Проблемы, которые решают микрофронтенды, в основном являются организационными, а не техническими. Такая проблема - это способность разных частей организации действовать независимо. Иметь возможность выпускать свой код в продакшен без одобрения остальных.
  - сокращение времени сборки
    - На сборку и автотесты больших интерфейсных приложений могут уходить часы, что значительно удлиняет цикл обратной связи с разработчиками. Разделив приложение на более мелкие части, мы можем радикально ускорить сборку и тесты.
  - переиспользование общего кода
    - для фронтенда важным ограничением является объем данных загруженных по сети, и чем он меньше тем лучше. Частая болячка микрофронтендов дублирование библиотек и кода фреймворков в их бандлах. В связи с этим мы максимально должны стараться переиспользовать общие модули и компоненты. Крайне важно придерживаться semantic versioning – BREAKING.FEATURE.FIX. И иметь механизм в микрофронтендах для анонсирования необходимых версий модулей и их загрузку в рантайме.
    - Болячки микрофронтендов
  - безопасное выполнение микрофронтендов
    - Микрофронтендов выполняются в браузере и работают в одном потоке. Модель DOM, которую можно рассматривать как замену хранилища данных, является общей, что означает, что они обращаются к одному и тому же хранилищу данных и изменяют его. И ошибка в одном микрофронтенде, может положить все клиентское приложение.
  - SSR – возможность генерации HTML-код страницы для поисковиков
  - Возможность управлять одним микрофронтендом из другого – к примеру, в sidebar'e показывать пункты меню, которые задаются в другом микросервисе
- Существующие решения
  - Server-Side Fragment Composition (на сервере)
    - Также известно под словами transclusion, Server Side Includes. Применяется на бэкенде. Когда веб-сервер собирает html-страницу из разных кусков (сервисов) в единую html страницу. Очень древняя технология.
    - Nginx SSI
    - Zalando Tailor – is a layout service that uses streams to compose a web page from fragment services.
    - слабо-применима к современным SPA-приложениям
  - Iframes (на клиенте)
    - transclusion который работает на клиенте. Который позволяет собирать html страницу из других html страниц. Появился как стандарт в HTML 4.01 (1998 год).
    - zoid (ифреймы могут общаться через postMessage)
    - боль с модальными окнами, и управлением лейаута
    - проблема с SEO для поисковиков
    - проблема с перформансом (одни и те же библиотеки загружаются несколько раз)
  - Web Components (на клиенте)
    - Гораздо более новым веб-стандартом являются веб-компоненты (2011-2013). Они позволяют определять и регистрировать динамические настраиваемые элементы в инкапсулированной области.
    - Самая большая проблема с SSR, т.к web components сильно завязаны на DOM API
    - Поможет инкапсулировать компонент, но не поможет сделать большое SPA приложение
    - По мне чутка поумневший iframe не более того.
  - next.js Multi Zones (на сервере) (Linked Pages & SPAs)
    - Подход при котором load-балансировщик согласно адреса страницы отдает то или иное SPA-приложение.
    - При таком подходе переход между приложениями будет "дорогим" для пользователя. Но роутинг внутри SPA-приложения будет дешевым и быстрым. Так же разработчики вольны выбирать любые средства разработки, для них разработка практически никак не усложняется.
  - single-spa (на клиенте)
    - Один из самых популярных фреймворков на данный момент для SPA. Это приложение-оболочка, которое включает приложения, разработанные с использованием других фреймворков. Он ведет себя как тонкий слой оркестровки, который согласно URL запускает тот или иной микрофронтенд, "выключая" предыдущий.
    - погружаемся в systemjs и мапперы, что-то костылим с подгрузкой ассетов css, fonts, images
    - проблема с переиспользованием кода, хотя lazy loading по роуту страницы позволяет сократить первоначальную загрузку
  - Module Federation
    - Новая киллер фича в Webpack 5.
    - Впервые озвучена Zack Jackson в [декабре 2018 github issue](https://github.com/webpack/webpack/issues/8524) ![first draft](https://user-images.githubusercontent.com/25274700/50267904-b7557e80-03dd-11e9-833a-88a0cb145b38.png)
    - Впервые анонсирована в виде статьи в [октябре 2019 года](https://medium.com/@ScriptedAlchemy/micro-fe-architecture-webpack-5-module-federation-and-custom-startup-code-9cb3fcd066c). Позволяет подключать модули из другой webpack-сборки, которая расположена на другом хосте. Если в systemjs вы вынуждены вручную собирать import maps, то с Module Federation это происходит автоматически под капотом. 
  - свой велосипед
    - обычно дорого – R&D, тесты, документация, bus factor
    - нужно опенсорсить, чтоб сократить косты на R&D
    - хорошо если на systemjs, еще лучше если на Module Federation
  - Таблица соответствия подходов тех. требованиям
- Module Federation
  - MF is a type of JavaScript architecture which invented and prototyped by Zack Jackson (ссылка на твиттер, ссылка на сайт).
  - Для MF начал ресерч и разработку в 2017mid
  - История
    - Это "адское" обсуждение в 389 комментов, 61 участник с 7 февраля по 7 октября 2020 [issue 10352](https://github.com/webpack/webpack/issues/10352)
    - Анонсирована в октябре 2019 как сторонний плагин
    - It was co-authored into Webpack 5 by myself (Zack Jackson) and Marais Rossouw with lots of guidance, pair-programming, and assistance from Tobias Koppers. <https://medium.com/swlh/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669>
    - Зарелизили в октябре 2020 как core-плагин
    - Tobias (Founder of Webpack) has helped visualize part of the beta.17 upgrade, which is what most of this article is based on. As always — The investment from Tobias has been a major factor in the ability to refine this system and make substantial changes to Webpack core to support this technology
  - Terminology
    - A host (consumers): a Webpack build that is initialized first during a page load (when the onLoad event is triggered)
    - A remote (consumable): another Webpack build, where part of it is being consumed by a “host”
    - Bidirectional hosts: when a bundle or Webpack build can work as a host or as a remote. Either consuming other applications or being consumed by others — at runtime
    - Omnidirectional hosts: when bundle operates as both host and remote at the same time
    - Exposed modules – модули которые будут доступны другим приложением для импорта
    - Shared module – модули которые могут быть общими для всем приложений (vendor eg React)
  - Module federation allows a JavaScript application to dynamically load code from another application — in the process, sharing dependencies, if an application consuming a federated module does not have a dependency needed by the federated code — Webpack will download the missing dependency from that federated build origin.
  - Webpack plugin that imports chunks from other Webpack bundles at runtime. To put it plainly, I want to merge two Webpack manifests at runtime and have them work together as if it was compiled as one SPA from the start.
  - Many webpack builds to act as one when in the browser, without context as build time. Better than DLLPlugin
  - Federated code can always load its dependencies but will attempt to use the consumers’ dependencies before downloading more payload. (Сперва посмотрит реакт у себя, прежде чем его скачивать с remote-host)
  - Все что может сбандлить Webpack (css, images, fonts) может быть зашарено между микрофронтендами.
  - Отдельные единицы развертывания могут иметь общие зависимости и зависеть друг от друга. Композиция выполняется во время выполнения, что облегчает независимое развертывание.
  - Объединенные модули могут иметь большое влияние на микрофронтенды, поскольку они позволяют разработчикам писать приложения, как если бы они были монолитными, тогда как на практике они распределяются по нескольким проектам.
  - Module federation нацелен на то, чтобы микрофронты могли легко совместно использовать общий код. Дублирование кода предотвращается за счет упрощения совместного использования.
  - module federation в webpack 5 (вот она рыба моей мечты)
  - The goals <https://levelup.gitconnected.com/micro-frontend-architecture-dynamic-import-chunks-from-another-webpack-bundle-at-runtime-1132d8cb6051>
    - No page refreshes when routing to another MFE, multiple apps should route as one SPA would
    - Don’t redownload vendor code that is already provided by another Webpack build on the page. (Don’t bundle multiple copies of the same dependency). So it’s just as efficient as if it was one large Webpack build, with code splitting.
    - Each MFE should be completely standalone and have no centralized dependency. I don’t want to share code by managing Webpack externals, or commons vendor chunks.
    - Frontend resources should have the ability to be evergreen, not requiring a consumer to re-install.
    - I should not need to redeploy the whole fleet because of a change to a shared component or something managed by another team (such as navigation, I don’t want to redeploy my all whenever they push a new update)
    - Orchestration should be completely managed in user-land, allowing dynamic adaptations based on what JavaScript bundles are loaded on a page. There should be no remote logic or calls required beyond adding static JavaScript like the bundles themselves.
  - SSR This project works client-side, but server-side is harder.
    - For ssr, we have taught webpack to work like browser on server side. Enabling chunks to be streamed over internal networks. Not limited to disk only or depend on getting html from separate servers
    - We have designed this to be Universal Module Federation works in any environment. Server-side rendering federated code is completely possible. Just have server builds use a commonjs library target. There are various ways to achieve federated SSR. S3 Streaming, ESI, automate an npm publish to consume server variants. I plan to use a commonly shared file volume or async S3 streaming to stream files across the filesystem. Enabling the server to require federated code just like it happens in the browser. Using fs instead of http to load federated code.
  - It’s important to note that this system is designed so that each completely standalone build/app can be in its own repository, deployed independently, and run as its own independent SPA.
- Демо
  - как работает (неглубоко без кишков, можно план демки взять здесь https://medium.com/swlh/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669)
  - Webpack конфиг
    - по настройке webpack конфига можно почитать тут https://medium.com/dev-genius/module-federation-advanced-api-inwebpack-5-0-0-beta-17-71cd4d42e534
    - For requiredVersion: ^, ~, >= and exact matching is allowed. Complex ranges are not supported as it would require a significant amount of runtime code to cover that logic.
  - кто реализует и можно ли доверять
  - где посмотреть больше демок
  - будут ли проблемы со сборкой, хэшами, ошибки в рантайме
- Стратегии использования Module Federation
  - State management. У каждого приложения должно быть своим. Глобальный стейт будет нарушать инкапсуляцию микросервисов. Если два микрофронтенда имеют много чего общего в стейте – скорее всего их следует объединить в один микрофронтенд.
  - тонкий шелл (уровне интеграции). Всё что является общим для многих микрофронтендов, можно разместить на уровне интеграции. Например, хедер, футер меню.
  - толстый шелл
  - и еще 100500 других
- Минусы Module Federation
  - это вебпак (ссылку на твит про ангела и демона) Ежики плачут, но продолжают есть кактус.
  - все еще новая технология. Но точно будет развиваться и набирать популярность.
  - не все паттерны и стратегии еще выработаны. Нам дали мяч, а вот с правилами игры пока не все ясно. Ждем адаптацию фреймворков, таких как next.js
  - SSR есть, но он tricky и я до него еще не добрался
  - В руках мастера может превратиться в черную дыру node_modules
  - С тестированием пока все сложно, если поменяете интерфейс exposed модуля, то ваше приложение сломается точно так же как если бы вы поменяли схему своего REST API
- Что дальше:
  - React 17
  - Ждем Next.js 11, но уже сейчас можно клеить микрофронтенды.
  - Выход с докладом на весну 2021: apollo federation, webpack module federation, russian federation – как сделать так, чтобы все федерации работали как часы?!
- Links
  - [Webpack 5 Module Federation - Zack Jackson 12 окт. 2020](https://www.youtube.com/watch?v=-ei6RqZilYI)
  - <https://medium.com/@ScriptedAlchemy>
  - <https://module-federation.github.io/>
  - <https://www.youtube.com/results?search_query=module+federation> Zack, Tobias, Jack Herrington
  - [Реакт хук для загрузки внешнего хоста](https://medium.com/@ScriptedAlchemy/webpack-5-module-federation-stitching-two-simple-bundles-together-fe4e6a069716)
