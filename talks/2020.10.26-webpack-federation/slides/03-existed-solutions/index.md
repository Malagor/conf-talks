# 3. Существующие решения

-----

- Server-Side Fragment Composition (на сервере)
  - Также известно под словами transclusion, Server Side Includes. Применяется на бэкенде. Когда веб-сервер собирает html-страницу из разных кусков (сервисов) в единую html страницу. Очень древняя технология.
  - Nginx SSI
  - Zalando Tailor – is a layout service that uses streams to compose a web page from fragment services.
  - слабо-применима к современным SPA-приложениям
- Iframes (на клиенте)
  - transclusion который работает на клиенте. Который позволяет собирать html страницу из других html страниц. Появился как стандарт в HTML 4.01 (1998 год).
  - zoid (ифреймы могут общаться через postMessage)
  - боль с модальными окнами, и управлением лейаута
  - проблема с SEO для поисковиков
  - проблема с перформансом (одни и те же библиотеки загружаются несколько раз)
- Web Components (на клиенте)
  - Гораздо более новым веб-стандартом являются веб-компоненты (2011-2013). Они позволяют определять и регистрировать динамические настраиваемые элементы в инкапсулированной области.
  - Самая большая проблема с SSR, т.к web components сильно завязаны на DOM API
  - Поможет инкапсулировать компонент, но не поможет сделать большое SPA приложение
  - По мне чутка поумневший iframe не более того.
- next.js Multi Zones (на сервере) (Linked Pages & SPAs)
  - Подход при котором load-балансировщик согласно адреса страницы отдает то или иное SPA-приложение.
  - При таком подходе переход между приложениями будет "дорогим" для пользователя. Но роутинг внутри SPA-приложения будет дешевым и быстрым. Так же разработчики вольны выбирать любые средства разработки, для них разработка практически никак не усложняется.
- single-spa (на клиенте)
  - Один из самых популярных фреймворков на данный момент для SPA. Это приложение-оболочка, которое включает приложения, разработанные с использованием других фреймворков. Он ведет себя как тонкий слой оркестровки, который согласно URL запускает тот или иной микрофронтенд, "выключая" предыдущий.
  - погружаемся в systemjs и мапперы, что-то костылим с подгрузкой ассетов css, fonts, images
  - проблема с переиспользованием кода, хотя lazy loading по роуту страницы позволяет сократить первоначальную загрузку
- Module Federation
  - Новая киллер фича в Webpack 5.
  - Впервые озвучена Zack Jackson в [декабре 2018 github issue](https://github.com/webpack/webpack/issues/8524) ![first draft](https://user-images.githubusercontent.com/25274700/50267904-b7557e80-03dd-11e9-833a-88a0cb145b38.png)
  - Впервые анонсирована в виде статьи в [октябре 2019 года](https://medium.com/@ScriptedAlchemy/micro-fe-architecture-webpack-5-module-federation-and-custom-startup-code-9cb3fcd066c). Позволяет подключать модули из другой webpack-сборки, которая расположена на другом хосте. Если в systemjs вы вынуждены вручную собирать import maps, то с Module Federation это происходит автоматически под капотом. 
- свой велосипед
  - обычно дорого – R&D, тесты, документация, bus factor
  - нужно опенсорсить, чтоб сократить косты на R&D
  - хорошо если на systemjs, еще лучше если на Module Federation
- Таблица соответствия подходов тех. требованиям